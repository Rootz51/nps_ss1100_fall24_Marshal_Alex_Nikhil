import random
import os
import sys

file_name = "current_state.txt" 

def apply_corrections(current_orientation, corrections):
    random_factor = random.uniform(0.95, 1.05)
    new_tuple = (
        current_orientation[0] + corrections[0] * random_factor,
        current_orientation[1] + corrections[1] * random_factor,
        current_orientation[2] + corrections[2] * random_factor
    )
    return new_tuple

def read_orientation_from_file(file_path):
    cwd = os.getcwd()
    full_file_path = os.path.join(cwd, file_path)
    if os.path.exists(full_file_path):
        with open(full_file_path, 'r') as file:
            line = file.readline().strip()
            orientation = tuple(map(float, line.split(',')))
    else:
        orientation = (random.randint(0, 360), random.randint(0, 360), random.randint(0, 360))
        write_orientation_to_file(full_file_path, orientation)
    return orientation

def write_orientation_to_file(file_path, orientation):
    cwd = os.getcwd()
    full_file_path = os.path.join(cwd, file_path)
    with open(full_file_path, 'w') as file:
        file.write(','.join(map(str, orientation)))

def main(input_tuple):
    starting_tuple = read_orientation_from_file(file_name)
    print(f"Current orientation is: x {starting_tuple[0]}, y {starting_tuple[1]}, z {starting_tuple[2]}")
    corrections = (input_tuple[0],input_tuple[1],input_tuple[2])
    result = apply_corrections(starting_tuple, corrections)
    write_orientation_to_file(file_name, result)
    print(f"New orientation is: x {result[0]}, y {result[1]}, z {result[2]}")

if __name__ == "__main__":
    read_orientation_from_file(file_name)

@author: alexanderbeyrooty
"""

import random
import os

# Simulated rotate_me function logic
def rotate_me(current_orientation, corrections):
    """ This function was adapted from suggestions generated by CHATGPT """
    """
    Simulate applying rotation corrections to adjust satellite orientation.
    Adds a small random error to simulate real-world inaccuracy.
    :param current_orientation: Tuple of current (X, Y, Z) orientation
    :param corrections: Tuple of rotation corrections (X, Y, Z)
    :return: Updated orientation after applying corrections
    """
    error = lambda: random.uniform(-0.1, 0.1)  # Random error between -0.1 and 0.1 degrees
    new_orientation = tuple(
        current + correction + error()
        for current, correction in zip(current_orientation, corrections)
    )
    return new_orientation


# Function to calculate rotation corrections
def calculate_rotation(current_orientation, target_orientation):
    """
    Calculate the rotation required in each axis to achieve the target orientation.
    :param current_orientation: Tuple of current (X, Y, Z) orientation
    :param target_orientation: Tuple of target (X, Y, Z) orientation
    :return: Tuple of rotation required in (X, Y, Z)
    """
    return tuple(target - current for current, target in zip(current_orientation, target_orientation))


# Function to check if orientation is within the tolerance
def within_tolerance(current_orientation, target_orientation, tolerance=0.1):
    """
    Check if the current orientation is within tolerance of the target orientation.
    :param current_orientation: Tuple of current (X, Y, Z) orientation
    :param target_orientation: Tuple of target (X, Y, Z) orientation
    :param tolerance: Allowed deviation in degrees
    :return: True if within tolerance, False otherwise
    """
    return all(
        abs(current - target) <= tolerance
        for current, target in zip(current_orientation, target_orientation)
    )


# Function to read the current state from a file
def read_current_state(file_path="current_state.txt"):
    """
    Read the current orientation from the state file.
    If the file doesn't exist, create it with an initial orientation of (0, 0, 0).
    :param file_path: Path to the file storing current orientation
    :return: Tuple of (X, Y, Z) orientation
    """
    if not os.path.exists(file_path):
        with open(file_path, "w") as file:
            file.write("0,0,0")  # Default initial state
    with open(file_path, "r") as file:
        data = file.readline().strip()
        return tuple(map(float, data.split(",")))


# Function to write the updated state to a file
def write_new_state(new_state, file_path="current_state.txt"):
    """
    Write the new orientation to the state file.
    :param new_state: Tuple of (X, Y, Z) orientation
    :param file_path: Path to the file storing new orientation
    """
    with open(file_path, "w") as file:
        file.write(",".join(map(str, new_state)))


# Main function to align the satellite
def align_satellite(target_orientation, initial_file="current_state.txt", tolerance=0.1):
    """
    Align the satellite to the target orientation using iterative corrections.
    :param target_orientation: Tuple of target (X, Y, Z) orientation
    :param initial_file: File storing the current state of the satellite
    :param tolerance: Allowed deviation in degrees
    """
    # Read current orientation from file
    current_orientation = read_current_state(initial_file)
    iteration = 0

    print(f"Starting alignment. Target orientation: {target_orientation}")
    while not within_tolerance(current_orientation, target_orientation, tolerance):
        iteration += 1
        print(f"\nIteration {iteration}:")
        print(f"Current orientation: {current_orientation}")

        # Calculate corrections
        corrections = calculate_rotation(current_orientation, target_orientation)
        print(f"Applying corrections: {corrections}")

        # Apply corrections using rotate_me function
        current_orientation = rotate_me(current_orientation, corrections)

        # Save updated state to file
        write_new_state(current_orientation, initial_file)
        print(f"Updated orientation: {current_orientation}")

    print("\nAlignment complete!")
    print(f"Final orientation: {current_orientation} (within {tolerance} degrees tolerance)")
    print(f"Total iterations: {iteration}")


# Entry point for running the script
if __name__ == "__main__":
    # Define target orientations for testing
    target_orientations = [
        (100, 200, 300),  # Test case 1
        (0, 0, 0),        # Test case 2
        (3, 30, 300)      # Test case 3
    ]

    # Run alignment for each target orientation
    for idx, target in enumerate(target_orientations, start=1):
        print(f"\n=== Aligning to Target Orientation {idx}: {target} ===")
        align_satellite(target)
